<script>
    // =============== CONFIGURACI√ìN √öNICA ===============
    const CONFIG = {
        MODEL_URL: "https://teachablemachine.withgoogle.com/models/_UsIOfbEQ/",
        MIN_CONFIDENCE: 0.65,
        API_ENDPOINT: "/api/chat",
        APP_VERSION: "2.0.0"
    };

    // =============== ESTADO DE LA APLICACI√ìN ===============
    let appState = {
        model: null,
        webcam: null,
        currentFood: "",
        currentConfidence: 0,
        selectedOption: null,
        isProcessing: false,
        cameraFacingMode: "environment",
        isUsingPhoto: false,
        lastResponse: null
    };

    // =============== ELEMENTOS DOM ===============
    const elements = {
        webcamViewer: document.getElementById('webcam-viewer'),
        imagePreview: document.getElementById('image-preview'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        detectedFood: document.getElementById('detectedFood'),
        confidenceValue: document.getElementById('confidenceValue'),
        confidenceBar: document.getElementById('confidenceBar'),
        detectionResults: document.getElementById('detectionResults'),
        conservationCard: document.getElementById('conservationCard'),
        recipesCard: document.getElementById('recipesCard'),
        responseContainer: document.getElementById('responseContainer'),
        responseTitle: document.getElementById('responseTitle'),
        aiBadge: document.getElementById('aiBadge'),
        responseTimestamp: document.getElementById('responseTimestamp'),
        aiResponse: document.getElementById('aiResponse'),
        loadingIndicator: document.getElementById('loadingIndicator'),
        errorContainer: document.getElementById('errorContainer'),
        captureBtn: document.getElementById('captureBtn'),
        appVersion: document.getElementById('appVersion'),
        connectionStatus: document.getElementById('connectionStatus')
    };

    // =============== API DE CHAT SIMPLIFICADA PERO FUNCIONAL ===============
    // Reemplaza tu api/chat.js con esta versi√≥n M√ÅS SIMPLE y confiable:
    
    // SOLUCI√ìN TEMPORAL: Usa esta funci√≥n en lugar de la API compleja
    async function getAISimpleResponse(food, option) {
        const responses = {
            conservation: {
                "manzana": "1. Guarda en refrigerador en bolsa perforada\n2. No lavar hasta consumir\n3. Separar de otras frutas maduras",
                "platano": "1. Guardar a temperatura ambiente\n2. Separar del resto de frutas\n3. Congelar si est√° muy maduro",
                "pan": "1. Guardar en bolsa de tela\n2. Congelar por rebanadas\n3. Tostar para recuperar textura",
                "lechuga": "1. Lavar, secar bien y guardar en recipiente herm√©tico\n2. Usar papel absorbente en el fondo\n3. Consumir en 3-4 d√≠as",
                "tomate": "1. Guardar a temperatura ambiente\n2. No refrigerar a menos que est√© maduro\n3. Alejado de la luz directa",
                "zanahoria": "1. Refrigerar en bolsa pl√°stica perforada\n2. Pueden durar hasta 2 semanas\n3. No lavar antes de guardar",
                "pollo": "1. Refrigerar m√°ximo 2 d√≠as\n2. Congelar en porciones\n3. Cocinar completamente",
                "pescado": "1. Consumir el mismo d√≠a\n2. Refrigerar con hielo\n3. Oler siempre antes de cocinar",
                "huevos": "1. Guardar en refrigerador\n2. No lavar la c√°scara\n3. Consumir en 3 semanas",
                "queso": "1. Guardar en papel encerado\n2. No en pl√°stico herm√©tico\n3. Consumir en 1-2 semanas"
            },
            recipes: {
                "manzana": "üçè Ensalada de manzana:\n- 2 manzanas\n- Yogur natural\n- Nueces\nPasos:\n1. Cortar manzanas\n2. Mezclar con yogur\n3. A√±adir nueces",
                "platano": "ü•§ Batido de pl√°tano:\n- 1 pl√°tano\n- 1 vaso leche\n- Miel\nPasos:\n1. Licuar todo\n2. Servir fr√≠o\n3. A√±adir miel",
                "pan": "üçû Pud√≠n de pan:\n- Pan duro\n- 2 huevos\n- Leche y az√∫car\nPasos:\n1. Remojar pan\n2. Mezclar con huevos\n3. Hornear 30 min",
                "lechuga": "ü•ó Ensalada fresca:\n- Lechuga\n- Tomate\n- Aceite de oliva\nPasos:\n1. Lavar y cortar\n2. Ali√±ar\n3. Servir al momento",
                "tomate": "üçÖ Sopa fr√≠a:\n- 4 tomates\n- 1 pepino\n- Ajo y aceite\nPasos:\n1. Licuar todo\n2. Enfriar 1 hora\n3. Servir con pan"
            }
        };

        // Retornar respuesta espec√≠fica o gen√©rica
        const optionResponses = responses[option] || responses.conservation;
        return optionResponses[food.toLowerCase()] || 
               `Consejos para ${food}:\n1. Almacenar en lugar fresco\n2. Consumir pronto\n3. Verificar estado diariamente`;
    }

    // =============== INICIALIZACI√ìN ===============
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            updateStatus('Iniciando aplicaci√≥n...', 'warning');
            
            // Cargar modelo
            await loadModel();
            
            // Iniciar c√°mara
            await initCamera();
            
            // Verificar conexi√≥n
            await checkConnection();
            
            // Iniciar loop de detecci√≥n
            startDetectionLoop();
            
            updateStatus('Listo para escanear', 'success');
            
        } catch (error) {
            console.error('Error inicializando:', error);
            updateStatus('Error de inicializaci√≥n', 'error');
            showError('No se pudo iniciar la aplicaci√≥n. Por favor, recarga la p√°gina.');
        }
    });

    // =============== FUNCIONES PRINCIPALES ===============
    async function loadModel() {
        try {
            elements.statusText.textContent = 'Cargando modelo...';
            
            const modelURL = CONFIG.MODEL_URL + "model.json";
            const metadataURL = CONFIG.MODEL_URL + "metadata.json";
            
            appState.model = await tmImage.load(modelURL, metadataURL);
            
            console.log('Modelo cargado:', appState.model);
            
        } catch (error) {
            console.error('Error cargando modelo:', error);
            showError('Modelo cargado en modo limitado');
            // Continuar sin modelo para pruebas
        }
    }

    async function initCamera() {
        try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('C√°mara no disponible');
            }
            
            const constraints = {
                video: {
                    facingMode: appState.cameraFacingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            };
            
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            
            if (appState.webcam) {
                appState.webcam.stop();
            }
            
            appState.webcam = new tmImage.Webcam(720, 720, true);
            await appState.webcam.setup(constraints);
            await appState.webcam.play();
            
            elements.webcamViewer.appendChild(appState.webcam.canvas);
            elements.captureBtn.disabled = false;
            
        } catch (error) {
            console.error('Error inicializando c√°mara:', error);
            showError('No se pudo acceder a la c√°mara. Usa la opci√≥n de subir foto.');
            elements.statusText.textContent = 'C√°mara no disponible';
        }
    }

    function startDetectionLoop() {
        async function loop() {
            if (!appState.isUsingPhoto && appState.webcam && appState.model) {
                appState.webcam.update();
                await detectFood(appState.webcam.canvas);
            }
            requestAnimationFrame(loop);
        }
        loop();
    }

    async function detectFood(imageElement) {
        try {
            if (!appState.model) return;
            
            const predictions = await appState.model.predict(imageElement);
            
            let highestConfidence = 0;
            let detectedClass = "";
            
            predictions.forEach(prediction => {
                if (prediction.probability > highestConfidence) {
                    highestConfidence = prediction.probability;
                    detectedClass = prediction.className;
                }
            });
            
            if (highestConfidence > CONFIG.MIN_CONFIDENCE && detectedClass !== appState.currentFood) {
                appState.currentFood = detectedClass;
                appState.currentConfidence = highestConfidence;
                
                updateDetectionUI(detectedClass, highestConfidence);
            }
            
        } catch (error) {
            console.error('Error en detecci√≥n:', error);
        }
    }

    function updateDetectionUI(food, confidence) {
        elements.detectedFood.textContent = food;
        elements.confidenceValue.textContent = `${(confidence * 100).toFixed(1)}%`;
        elements.confidenceBar.style.width = `${confidence * 100}%`;
        elements.detectionResults.style.display = 'block';
    }

    async function captureImage() {
        if (appState.isProcessing) return;
        
        appState.isProcessing = true;
        elements.captureBtn.disabled = true;
        
        try {
            // Crear canvas temporal
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            canvas.width = appState.webcam.canvas.width;
            canvas.height = appState.webcam.canvas.height;
            
            context.drawImage(appState.webcam.canvas, 0, 0, canvas.width, canvas.height);
            
            // Procesar imagen
            await processImage(canvas);
            
        } catch (error) {
            console.error('Error capturando imagen:', error);
            showError('Error al capturar la foto');
        } finally {
            appState.isProcessing = false;
            elements.captureBtn.disabled = false;
        }
    }

    async function processImage(canvas) {
        try {
            // Redimensionar si es necesario
            const resizedCanvas = resizeCanvas(canvas, 224, 224);
            
            // Detectar
            const predictions = await appState.model.predict(resizedCanvas);
            const topPrediction = predictions[0];
            
            appState.currentFood = topPrediction.className;
            appState.currentConfidence = topPrediction.probability;
            
            updateDetectionUI(topPrediction.className, topPrediction.probability);
            
        } catch (error) {
            console.error('Error procesando imagen:', error);
            showError('Error al analizar la imagen');
        }
    }

    function resizeCanvas(canvas, width, height) {
        const resizedCanvas = document.createElement('canvas');
        const ctx = resizedCanvas.getContext('2d');
        
        resizedCanvas.width = width;
        resizedCanvas.height = height;
        
        ctx.drawImage(canvas, 0, 0, width, height);
        
        return resizedCanvas;
    }

    // =============== MANEJO DE ARCHIVOS MEJORADO ===============
    async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Validaciones MEJORADAS
        const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
        
        if (!validTypes.includes(file.type.toLowerCase())) {
            showError(`Formato no soportado. Usa: ${validTypes.join(', ')}`);
            return;
        }
        
        if (file.size > 10 * 1024 * 1024) { // 10MB
            showError('La imagen es demasiado grande (m√°ximo 10MB)');
            return;
        }
        
        appState.isProcessing = true;
        appState.isUsingPhoto = true;
        
        try {
            // Mostrar preview
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                const img = new Image();
                img.onload = async () => {
                    // Crear canvas y dibujar imagen
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Convertir a formato compatible si es necesario
                    const compatibleCanvas = ensureImageCompatibility(canvas);
                    
                    await processImage(compatibleCanvas);
                    
                    // Mostrar preview
                    elements.imagePreview.src = img.src;
                    elements.imagePreview.style.display = 'block';
                    elements.webcamViewer.style.display = 'none';
                    
                    appState.isUsingPhoto = false;
                    appState.isProcessing = false;
                };
                
                img.onerror = () => {
                    showError('Error cargando la imagen. Intenta con otra.');
                    appState.isProcessing = false;
                    appState.isUsingPhoto = false;
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = () => {
                showError('Error leyendo el archivo');
                appState.isProcessing = false;
                appState.isUsingPhoto = false;
            };
            
            reader.readAsDataURL(file);
            
        } catch (error) {
            console.error('Error subiendo archivo:', error);
            showError('Error al procesar la imagen');
            appState.isProcessing = false;
            appState.isUsingPhoto = false;
        }
    }

    // Funci√≥n para asegurar compatibilidad de im√°genes
    function ensureImageCompatibility(canvas) {
        // Crear nuevo canvas con formato RGB est√°ndar
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvas.width;
        newCanvas.height = canvas.height;
        const ctx = newCanvas.getContext('2d');
        
        // Dibujar imagen original
        ctx.drawImage(canvas, 0, 0);
        
        // Si la imagen tiene transparencia, rellenar fondo blanco
        if (isTransparent(canvas)) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fondo blanco
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Dibujar imagen sobre fondo blanco
            tempCtx.drawImage(canvas, 0, 0);
            
            return tempCanvas;
        }
        
        return newCanvas;
    }

    function isTransparent(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, 1, 1);
        return imageData.data[3] < 255; // Canal alfa < 255
    }

    // =============== OPCIONES Y IA ===============
    function selectOption(option) {
        if (!appState.currentFood || appState.isProcessing) return;
        
        appState.selectedOption = option;
        
        // Actualizar UI
        elements.conservationCard.classList.remove('selected');
        elements.recipesCard.classList.remove('selected');
        
        if (option === 'conservation') {
            elements.conservationCard.classList.add('selected');
            getAIResponse('conservation');
        } else {
            elements.recipesCard.classList.add('selected');
            getAIResponse('recipes');
        }
    }

    async function getAIResponse(option) {
        if (!appState.currentFood || appState.isProcessing) return;
        
        appState.isProcessing = true;
        
        try {
            // Mostrar UI de carga
            elements.responseContainer.style.display = 'block';
            elements.aiResponse.style.display = 'none';
            elements.loadingIndicator.style.display = 'flex';
            elements.errorContainer.style.display = 'none';
            
            // Configurar t√≠tulo
            const titles = {
                conservation: `Conservaci√≥n: ${appState.currentFood}`,
                recipes: `Recetas con ${appState.currentFood}`
            };
            elements.responseTitle.textContent = titles[option];
            elements.aiBadge.innerHTML = option === 'conservation' 
                ? '<span>‚ùÑÔ∏è</span><span>Conservaci√≥n</span>' 
                : '<span>üç≥</span><span>Recetas</span>';
            
            // SOLUCI√ìN TEMPORAL: Usar respuestas locales en lugar de API
            const response = await getAISimpleResponse(appState.currentFood, option);
            
            // Mostrar respuesta
            displayAIResponse(response, option);
            
        } catch (error) {
            console.error('Error obteniendo respuesta de IA:', error);
            displayError('Usando modo local. La IA estar√° disponible pronto.');
            
            // Mostrar respuesta de respaldo
            const fallback = option === 'conservation' 
                ? `Consejos b√°sicos para ${appState.currentFood}:\n1. Guardar en refrigerador\n2. Consumir en 3-5 d√≠as\n3. Verificar estado diario`
                : `Receta b√°sica con ${appState.currentFood}:\n1. Saltear con aceite\n2. A√±adir especias\n3. Servir caliente`;
            
            displayAIResponse(fallback, option);
            
        } finally {
            appState.isProcessing = false;
            elements.loadingIndicator.style.display = 'none';
        }
    }

    function displayAIResponse(response, option) {
        elements.responseTimestamp.textContent = 'Justo ahora';
        
        // Formatear respuesta
        let formattedText = response
            .replace(/\n/g, '<br>')
            .replace(/\d+\.\s/g, '<strong>$&</strong>');
        
        elements.aiResponse.innerHTML = formattedText;
        elements.aiResponse.style.display = 'block';
        
        // Guardar √∫ltima respuesta
        appState.lastResponse = {
            option,
            food: appState.currentFood,
            response: response,
            timestamp: new Date().toISOString()
        };
    }

    // =============== UTILIDADES ===============
    function displayError(message) {
        elements.errorContainer.style.display = 'block';
        elements.errorContainer.innerHTML = `
            <div style="padding: 1rem; background: #fef2f2; border-radius: 8px; color: #dc2626; border: 1px solid #fecaca;">
                <strong>‚ö†Ô∏è Error</strong><br>
                ${message}
            </div>
        `;
    }

    async function checkConnection() {
        try {
            // Intentar cargar la API
            const response = await fetch(CONFIG.API_ENDPOINT, { method: 'GET' });
            
            if (response.ok) {
                elements.connectionStatus.textContent = 'Conectado ‚úì';
                elements.connectionStatus.style.color = '#10B981';
                return true;
            }
        } catch (error) {
            console.log('API no disponible, usando modo local');
        }
        
        // Si falla, usar modo local
        elements.connectionStatus.textContent = 'Modo local (sin IA)';
        elements.connectionStatus.style.color = '#F59E0B';
        return false;
    }

    function updateStatus(message, type = 'info') {
        elements.statusText.textContent = message;
        
        const dot = elements.statusBadge.querySelector('.status-dot');
        dot.style.background = type === 'success' ? '#10B981' :
                              type === 'warning' ? '#F59E0B' :
                              type === 'error' ? '#EF4444' :
                              '#9CA3AF';
    }

    function showError(message) {
        // Mostrar error temporal
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #EF4444;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideIn 0.3s ease;
        `;
        
        // Agregar animaci√≥n CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        
        errorDiv.innerHTML = `‚ùå ${message}`;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.remove();
            }
        }, 5000);
    }

    function flipCamera() {
        try {
            appState.cameraFacingMode = appState.cameraFacingMode === 'environment' ? 'user' : 'environment';
            initCamera();
        } catch (error) {
            console.error('Error cambiando c√°mara:', error);
            showError('No se pudo cambiar la c√°mara');
        }
    }

    // Actualizar versi√≥n
    elements.appVersion.textContent = `v${CONFIG.APP_VERSION} ‚Ä¢ `;
</script>
